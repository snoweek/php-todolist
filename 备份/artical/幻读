
读现象

“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。
1.幻读:是指将同一条 SELECT 语句执行两次，得到了不同的“数据集”（就是说两次返回的不是同一批数据）,或者说数据的个数不同。
SELECT id FROM test;    =>  1,2,5
SELECT id FROM test;    =>  1,2,5,6 
出现这种请况一般是因为在第二次 SELECT 执行前，有其他事务进行了 INSERT 或 DELETE 操作，并进行了提交。
是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉
及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。
那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

2.不可重复读：还是将一条 SELECT 语句执行两次，某个特定的条目在这两次查询中返回的值不一样，就叫“不可重复读”。
SELECT id, name FROM test;    =>   (1,"n1"), (2, "n2), (5, "n5")
SELECT id, name FROM test;    =>   (1, "n1"), (2, "David"), (5, "n5")
注意，返回的仍然是主键为 1,2,5 的数据，但 id=2 的那行数据的 name 变了
在同一事务中，多次读取同一数据返回的结果有所不同
是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。
那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的
数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
换句话说就是，后续读取可以读到另一事务已提交的

这种情况的原因是：在第二次 SELECT 前，其它事务对此条目进行了 UPDATE，并进行了提交。
3.脏读
脏读发生的前提是一个事务能读到其他事务中未提交的操作。
如果在读取到这样的数据后，那个事务进行了回滚，我们就相当于读到了数据库中不再存在的数据（也就是“脏数据”）。
一个事务读取到另一事务未提交的更新新据
当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有
提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作也可能是不正确的。

这三种读现象是并列、互不相关的，例如在某个隔离等级中出现了“不可重复读”，并不意味着就一定也能出现“幻读”。



ACID，指数据库事务正确执行的四个基本要素的缩写。
包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
事务隔离级别（transaction isolation levels）：隔离级别就是对对事务并发控制的等级。ANSI/ ISO SQL将其分为串行化（SERIALIZABLE）、可重复读（REPEATABLE READ）、读已提交（READ COMMITED）、读未提交（READ UNCOMMITED）四个等级。为了实现隔离级别通常数据库采用锁（Lock）。一般在编程的时候只需要设置隔离等级，至于具体采用什么锁则由数据库来设置
隔离级别
SQL 标准中定义了4个隔离级别，一般来说，隔离级别越高，会出现的“读现象”就越少。
但这只是一个规范。每种隔离级别在不同的数据库中有不同的特性和实现方式。
这4个级别由高到低依次为：
1.Serializable （可串行化）：简单的说，此级别下运行的事务是完全隔离的，不会受到其他事务的干扰（因此不会出现任何“读现象”）。
其他事务中对数据进行的更新，在此事务中不可见（但可能导致此事务执行失败）。

从技术上来说，此级别下的事务必须以串行的方式被执行，或者至少是串行等价的，否则会以报错的形式结束并回滚。
“串行”也就是一个接一个的运行，这种情况下一个事务当然不会被其他事务干扰。
“串行等价”的意思就是：两个/多个事务就算同时运行（并行），得到的结果也和一个接一个的运行（串行）一样。所以对于这些事务，即使同时运行也没关系。

这是一个最理想的级别，我们可以认为在这个级别下不会因事务间的冲突而破坏数据一致性。
但相对的，性能也最低，所以不常用（也因此我实际并没有在此级别下运行过 SQL 语句，不清楚它到底有多强大）。
2.Repeatable reads （可重复读）
比可串行化稍宽松一点的级别。
根据定义，此级别中不会出现“不可重复读”的现象，也就是其他事务对某行数据的更改无论提交没提交，都不会反应到当前事务中。
但是允许出现“幻读”，也就是其他事务中插入的新数据，允许出现在当前事务里。

3.Read committed（提交读/读已提交）
此级别中，其他事务对数据进行的更改只要一提交，就可以在当前事务中读取到。因此会出现“不可重复读”和“幻读”。

4.Read uncommitted（未提交读/读未提交）
这是最宽松的级别。其他事务对数据进行的任意更改就算没提交，也会立刻反应到当前事务中。
所有读现象都可能出现在这个级别中。
因为太宽松了，这个级别很少被用到。


MySQL 的默认事务级别是 Repeatable read

 

      
 
